{
  "experiment": "humaneval_sample",
  "budget": "free",
  "timestamp": "2026-02-20T16:30:29.250Z",
  "results": [
    {
      "id": "he_001",
      "question": "Write a Python function that takes a list of integers and returns the sum of all even numbers.",
      "ground_truth": "def sum_even(numbers: list[int]) -> int:\n    return sum(n for n in numbers if n % 2 == 0)",
      "model_answer": "0",
      "confidence": 1,
      "is_correct": false,
      "complexity_tier": "MEDIUM",
      "latency_ms": 6592,
      "cost_usd": 0,
      "votes": [
        {
          "model": "Arcee AI: Trinity Large Preview (free)",
          "answer": "To solve this, the first step is to iterate through the list and check each number to see if it's even. The simplest way to do that is by using the modulo operator: if a number divided by 2 leaves a remainder of 0, it's even. As we find even numbers, we can keep a running total. Once we've gone through the entire list, we return that total.\n\nHere's how that looks in code:\n\n```python\ndef sum_even_numbers(numbers):\n    total = 0\n    for num in numbers:\n        if num % 2 == 0:\n            total += num\n    return total\n```\n\nFor example, calling `sum_even_numbers([1, 2, 3, 4, 5, 6])` would return `12`, since 2 + 4 + 6 = 12.",
          "agrees": true
        }
      ]
    },
    {
      "id": "he_002",
      "question": "Write a function that reverses a string without using built-in reverse methods.",
      "ground_truth": "def reverse_string(s: str) -> str:\n    return s[::-1]",
      "model_answer": "0",
      "confidence": 1,
      "is_correct": false,
      "complexity_tier": "MEDIUM",
      "latency_ms": 17056,
      "cost_usd": 0,
      "votes": [
        {
          "model": "Qwen: Qwen3 235B A22B Thinking 2507",
          "answer": "To reverse a string without using built-in reverse methods, we can use a two-pointer approach. This method efficiently swaps characters from both ends of the string moving towards the center, ensuring optimal performance with O(n) time complexity and O(n) space complexity (due to string immutability in Python).\n\n### Approach\n1. **Convert to Mutable List**: Since strings in Python are immutable, convert the input string into a list of characters to allow in-place modifications.\n2. **Two-Pointer Swap**: Initialize two pointers:\n   - `left` starting at the beginning (index 0)\n   - `right` starting at the end (index `len(s) - 1`)\n3. **Iterate and Swap**: While `left` is less than `right`:\n   - Swap the characters at `left` and `right` pointers.\n   - Move `left` forward and `right` backward.\n4. **Reconstruct String**: Convert the modified list back to a string.\n\n### Solution Code\n```python\ndef reverse_string(s):\n    chars = list(s)\n    left, right = 0, len(chars) - 1\n    while left < right:\n        chars[left], chars[right] = chars[right], chars[left]\n        left += 1\n        right -= 1\n    return ''.join(chars)\n```\n\n### Explanation\n1. **Conversion to List**: The input string `s` is converted into a list `chars` to enable character swapping (since strings cannot be modified directly).\n2. **Pointer Initialization**: `left` starts at the first character (index 0), and `right` starts at the last character (index `len(chars) - 1`).\n3. **Swapping Process**: \n   - The loop continues as long as `left` is less than `right`.\n   - Characters at positions `left` and `right` are swapped.\n   - `left` is incremented and `right` is decremented to move towards the center.\n4. **Result Construction**: The modified list `chars` is joined back into a single string, which is the reversed version of the input.\n\nThis approach efficiently reverses the string by minimizing operations to exactly half the string length (n/2 swaps), making it both time and space optimal for the given constraints. \n\n**Example**:  \nInput: `\"hello\"`  \n- Step 1: Convert to list `['h', 'e', 'l', 'l', 'o']`  \n- Step 2: Swap `h` (index 0) and `o` (index 4) → `['o', 'e', 'l', 'l', 'h']`  \n- Step 3: Swap `e` (index 1) and `l` (index 3) → `['o', 'l', 'l', 'e', 'h']`  \n- Result: `\"olleh\"`",
          "agrees": true
        }
      ]
    },
    {
      "id": "he_003",
      "question": "Write a function that finds the maximum element in a list.",
      "ground_truth": "def find_max(numbers: list) -> int:\n    if not numbers:\n        raise ValueError('Empty list')\n    return max(numbers)",
      "model_answer": "To solve this, the first thing to consider is how to handle an empty list—since there's no maximum in that case, returning None makes sense. For non-empty lists, we can start by assuming the first element is the maximum. Then, by iterating through the rest of the list, we compare each element to our current maximum, updating it whenever we find a larger value. This approach ensures we check every element exactly once, making it efficient.\n\nHere's how that looks in code:\n\n```python\ndef find_max(lst):\n    if not lst:\n        return None\n    max_val = lst[0]\n    for num in lst[1:]:\n        if num > max_val:\n            max_val = num\n    return max_val\n```\n\nThis function will return the largest element in the list, or None if the list is empty.",
      "confidence": 0.5,
      "is_correct": false,
      "complexity_tier": "MEDIUM",
      "latency_ms": 18464,
      "cost_usd": 0,
      "votes": [
        {
          "model": "Free Models Router",
          "answer": "To solve this, the first thing to consider is how to handle an empty list—since there's no maximum in that case, returning None makes sense. For non-empty lists, we can start by assuming the first element is the maximum. Then, by iterating through the rest of the list, we compare each element to our current maximum, updating it whenever we find a larger value. This approach ensures we check every element exactly once, making it efficient.\n\nHere's how that looks in code:\n\n```python\ndef find_max(lst):\n    if not lst:\n        return None\n    max_val = lst[0]\n    for num in lst[1:]:\n        if num > max_val:\n            max_val = num\n    return max_val\n```\n\nThis function will return the largest element in the list, or None if the list is empty.",
          "agrees": true
        },
        {
          "model": "Qwen: Qwen3 VL 235B A22B Thinking",
          "answer": "To solve this problem, we need to find the maximum element in a given list. The solution involves iterating through the list while keeping track of the largest element encountered so far. \n\n### Approach\n1. **Check for Empty List**: If the input list is empty, return `None` since there is no maximum element.\n2. **Initialize Maximum Value**: Start by assuming the first element of the list is the maximum.\n3. **Iterate Through the List**: For each subsequent element in the list, compare it with the current maximum. If an element is larger than the current maximum, update the maximum value.\n4. **Return the Result**: After processing all elements, return the maximum value found.\n\nThis approach efficiently processes the list in a single pass, resulting in a time complexity of O(n), where n is the number of elements in the list. The space complexity is O(1) since we only use a constant amount of additional space.\n\n### Solution Code\n```python\ndef find_max(lst):\n    if not lst:\n        return None\n    max_val = lst[0]\n    for num in lst[1:]:\n        if num > max_val:\n            max_val = num\n    return max_val\n```\n\n### Explanation\n1. **Empty List Check**: The function first checks if the list is empty. If it is, the function returns `None` immediately.\n2. **Initialization**: The variable `max_val` is initialized to the first element of the list.\n3. **Iteration and Comparison**: The loop starts from the second element (index 1) and compares each element with `max_val`. If a larger element is found, `max_val` is updated to this new value.\n4. **Result**: After the loop completes, `max_val` holds the largest element in the list, which is then returned.\n\nThis method ensures that every element is checked exactly once, making it both efficient and straightforward for finding the maximum element in any list of comparable elements.",
          "agrees": false
        }
      ]
    },
    {
      "id": "he_005",
      "question": "Write a function that returns the factorial of a number.",
      "ground_truth": "def factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError('Negative number')\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)",
      "model_answer": "1",
      "confidence": 0.5,
      "is_correct": false,
      "complexity_tier": "MEDIUM",
      "latency_ms": 13407,
      "cost_usd": 0,
      "votes": [
        {
          "model": "Free Models Router",
          "answer": "To solve this, the first thing to consider is how to handle edge cases. The factorial of 0 is defined as 1, so that's an immediate return value. For negative numbers, since factorial isn't defined, it's best to raise an error.\n\nFor the actual calculation, recursion is a natural fit: n! = n x (n-1)!. But recursion can hit stack limits for large n, so an iterative approach is safer and more efficient. Starting with a result of 1, multiply it by each integer from 1 up to n. This way, both 0 and positive integers are handled cleanly.\n\nHere's the implementation:\n\n```python\ndef factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n```\n\nThis handles all valid inputs and avoids recursion depth issues.",
          "agrees": true
        },
        {
          "model": "Qwen: Qwen3 235B A22B Thinking 2507",
          "answer": "To solve this problem, we need to compute the factorial of a non-negative integer. The factorial of a number \\( n \\) (denoted as \\( n! \\)) is the product of all positive integers less than or equal to \\( n \\). By definition, the factorial of 0 is 1. \n\n### Approach\n1. **Problem Analysis**: The factorial function is only defined for non-negative integers. For any negative input, the function should handle it appropriately (e.g., return `None` or raise an error). \n2. **Key Insight**: The factorial of 0 is 1, which serves as the base case. For positive integers, the factorial can be computed iteratively by multiplying all integers from 1 up to \\( n \\).\n3. **Algorithm Selection**: An iterative approach is chosen over recursion to avoid stack overflow for large values of \\( n \\) and for better efficiency.\n4. **Edge Cases**: \n   - If \\( n \\) is 0, return 1.\n   - If \\( n \\) is negative, return `None` (as factorial is undefined for negative numbers).\n\n### Solution Code\n```python\ndef factorial(n):\n    if n < 0:\n        return None\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n```\n\n### Explanation\n1. **Input Validation**: The function first checks if the input \\( n \\) is negative. If so, it returns `None` because factorial is undefined for negative numbers.\n2. **Base Case Handling**: If \\( n \\) is 0, the loop does not execute (since the range starts from 1), and the initial value of `result` (1) is returned directly.\n3. **Iterative Calculation**: For positive integers, the loop runs from 1 to \\( n \\) (inclusive), multiplying each integer with the running product stored in `result`.\n4. **Efficiency**: The algorithm runs in \\( O(n) \\) time, which is optimal for this problem, as each number from 1 to \\( n \\) must be processed exactly once. The space complexity is \\( O(1) \\) since only a single variable (`result`) is used.\n\nThis approach efficiently handles all valid inputs and correctly manages edge cases, ensuring robustness and correctness.",
          "agrees": false
        }
      ]
    },
    {
      "id": "he_006",
      "question": "Write a function that removes duplicates from a list while preserving order.",
      "ground_truth": "def remove_duplicates(items: list) -> list:\n    seen = set()\n    result = []\n    for item in items:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result",
      "model_answer": "To tackle this, the first thought is to use a set to track what's already been seen, since checking membership in a set is fast. But sets don't remember the order, so we'll need to build a new list as we go. As we iterate through the original list, each time we encounter an element not in the set, we add it to both the set and the result list. If it's already in the set, we skip it. This way, the first occurrence of each element is kept, and the order is preserved.\n\nHere's how that looks in code:\n\n```python\ndef remove_duplicates(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result\n```\n\nThis approach works efficiently for lists of hashable items. If the list contains unhashable elements like lists or dictionaries, a different method would be needed, but for most common cases, this solution is both simple and effective.",
      "confidence": 1,
      "is_correct": false,
      "complexity_tier": "COMPLEX",
      "latency_ms": 10098,
      "cost_usd": 0,
      "votes": [
        {
          "model": "Free Models Router",
          "answer": "To tackle this, the first thought is to use a set to track what's already been seen, since checking membership in a set is fast. But sets don't remember the order, so we'll need to build a new list as we go. As we iterate through the original list, each time we encounter an element not in the set, we add it to both the set and the result list. If it's already in the set, we skip it. This way, the first occurrence of each element is kept, and the order is preserved.\n\nHere's how that looks in code:\n\n```python\ndef remove_duplicates(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result\n```\n\nThis approach works efficiently for lists of hashable items. If the list contains unhashable elements like lists or dictionaries, a different method would be needed, but for most common cases, this solution is both simple and effective.",
          "agrees": true
        }
      ]
    },
    {
      "id": "he_009",
      "question": "Write a function that merges two sorted lists into one sorted list.",
      "ground_truth": "def merge_sorted(list1: list, list2: list) -> list:\n    return sorted(list1 + list2)",
      "model_answer": "0",
      "confidence": 0.5,
      "is_correct": false,
      "complexity_tier": "MEDIUM",
      "latency_ms": 16594,
      "cost_usd": 0,
      "votes": [
        {
          "model": "Arcee AI: Trinity Large Preview (free)",
          "answer": "To merge two sorted lists into one sorted list, the most efficient approach is to use a two-pointer technique. This method allows us to traverse both lists simultaneously, always picking the smaller current element and appending it to the result. This ensures that the merged list remains sorted without needing to sort it again afterward.\n\nHere's how the process works:\n\n1. Initialize two pointers, each starting at the beginning of the two input lists.\n2. Compare the elements at both pointers.\n3. Append the smaller element to the result list and move that pointer forward.\n4. Repeat this process until one of the lists is fully traversed.\n5. Once one list is exhausted, append the remaining elements from the other list to the result.\n\nThis approach is efficient, with a time complexity of O(n + m), where n and m are the lengths of the two lists.\n\nHere's the implementation:\n\n```python\ndef merge_sorted_lists(list1, list2):\n    i, j = 0, 0\n    merged = []\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            merged.append(list1[i])\n            i += 1\n        else:\n            merged.append(list2[j])\n            j += 1\n    # Append any remaining elements\n    merged.extend(list1[i:])\n    merged.extend(list2[j:])\n    return merged\n```\n\nThis function will merge two sorted lists into a single sorted list efficiently.",
          "agrees": true
        },
        {
          "model": "Qwen: Qwen3 VL 235B A22B Thinking",
          "answer": "To merge two sorted lists into one sorted list efficiently, we can use a two-pointer technique. This approach leverages the fact that both input lists are already sorted, allowing us to merge them in linear time, O(n + m), where n and m are the lengths of the two lists.\n\n### Approach\n1. **Initialize Pointers**: Start with two pointers, one for each list, both set to the beginning (index 0).\n2. **Compare and Merge**: Compare the elements at the current pointers of both lists. Append the smaller element to the result list and move the corresponding pointer forward.\n3. **Handle Remaining Elements**: Once one list is exhausted, append all remaining elements from the other list to the result.\n\nThis method ensures that we only traverse each element once, making it optimal for merging sorted lists.\n\n### Solution Code\n```python\ndef merge_sorted_lists(list1, list2):\n    result = []\n    i = j = 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    return result\n```\n\n### Explanation\n1. **Initialization**: The `result` list is initialized to store the merged output. Pointers `i` and `j` start at the beginning of `list1` and `list2` respectively.\n2. **Merging Process**: \n   - While both pointers are within their respective lists, compare elements at `list1[i]` and `list2[j]`.\n   - The smaller element is appended to `result`, and the corresponding pointer is incremented.\n3. **Appending Remaining Elements**: \n   - After one list is exhausted, any remaining elements in the other list are appended to `result` using `extend`.\n   - This handles cases where one list is longer than the other.\n\nThis approach efficiently combines the two sorted lists by processing each element exactly once, resulting in an optimal O(n + m) time complexity, where n and m are the lengths of the input lists. The space complexity is O(n + m) to store the merged result.",
          "agrees": false
        }
      ]
    },
    {
      "id": "he_010",
      "question": "Write a function that finds the first non-repeating character in a string.",
      "ground_truth": "def first_unique_char(s: str) -> str:\n    from collections import Counter\n    counts = Counter(s)\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return ''",
      "model_answer": "1",
      "confidence": 1,
      "is_correct": false,
      "complexity_tier": "MEDIUM",
      "latency_ms": 19202,
      "cost_usd": 0,
      "votes": [
        {
          "model": "Qwen: Qwen3 235B A22B Thinking 2507",
          "answer": "To solve this problem, we need to find the first non-repeating character in a given string. A non-repeating character is one that appears exactly once in the string, and we need the first such character in the order of their appearance.\n\n### Approach\n1. **Count Frequencies**: Traverse the string once to count the frequency of each character using a dictionary. This helps in identifying how many times each character appears in the string.\n2. **Find First Non-Repeating Character**: Traverse the string again to find the first character with a frequency count of exactly 1. This ensures we return the first character in the original string order that does not repeat.\n3. **Handle Edge Cases**: If the string is empty or all characters repeat, return `None` to indicate no such character exists.\n\n### Solution Code\n```python\ndef first_non_repeating_char(s):\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None\n```\n\n### Explanation\n1. **Counting Frequencies**: The first loop iterates through each character in the string, updating its count in the dictionary `char_count`. For example, for the string `\"leetcode\"`, the dictionary would be `{'l': 1, 'e': 3, 't': 1, 'c': 1, 'o': 1, 'd': 1}`.\n2. **Finding the First Non-Repeating Character**: The second loop checks each character in the original string order. The first character encountered with a count of 1 is returned immediately. In `\"leetcode\"`, `'l'` is the first character with a count of 1, so it is returned.\n3. **Edge Handling**: If no character with a count of 1 is found (e.g., in `\"aabb\"`), the function returns `None`.\n\nThis approach efficiently combines two passes over the string: one to count frequencies and another to find the first non-repeating character, ensuring optimal performance with O(n) time complexity, where n is the length of the string. The space complexity is O(1) since the dictionary size is bounded by the number of distinct characters (constant for standard character sets).",
          "agrees": true
        }
      ]
    }
  ],
  "metrics": {
    "total_cases": 7,
    "accuracy": 0,
    "avg_confidence": 0.7857142857142857,
    "ece": 0.7857142857142857,
    "brier_score": 0.6785714285714286,
    "confidence_bins": [
      {
        "range": "0.0-0.2",
        "count": 0,
        "accuracy": 0,
        "avg_confidence": 0
      },
      {
        "range": "0.2-0.4",
        "count": 0,
        "accuracy": 0,
        "avg_confidence": 0
      },
      {
        "range": "0.4-0.6",
        "count": 3,
        "accuracy": 0,
        "avg_confidence": 0.5
      },
      {
        "range": "0.6-0.8",
        "count": 0,
        "accuracy": 0,
        "avg_confidence": 0
      },
      {
        "range": "0.8-1.0",
        "count": 4,
        "accuracy": 0,
        "avg_confidence": 1
      }
    ]
  }
}